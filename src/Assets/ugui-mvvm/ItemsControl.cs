using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;

namespace uguimvvm
{
    /// <summary>
    /// Represents a control that can be used to present a collection of items.
    /// </summary>
    public class ItemsControl : MonoBehaviour
    {
        /// <summary>
        /// Flag indicating that controls should be recycled on <see cref="NotifyCollectionChangedAction.Reset"/>, rather than discarded in favor of new instances.
        /// </summary>
        [SerializeField]
        [Tooltip("When a Reset event happens, reuse controls rather than just completely Destroy/Instantiate everything")]
        protected bool _reuseControlsForReset = false;

        /// <summary>
        /// Represents a generic item from an <see cref="ItemsSource"/>, along with associated content generated by the <see cref="ItemsControl"/>.
        /// </summary>
        protected class ItemInfo
        {
            /// <summary>
            /// The original item from the <see cref="ItemsSource"/>.
            /// </summary>
            public readonly object Item;

            /// <summary>
            /// The instantiated control representing this <see cref="Item"/>.
            /// </summary>
            public readonly GameObject Control;

            /// <summary>
            /// The <see cref="RectTransform"/> of the <see cref="Control"/>, if defined.
            /// </summary>
            public readonly RectTransform Rect;

            /// <summary>
            /// Creates a new <see cref="ItemInfo"/>.
            /// </summary>
            /// <param name="item">The original item from the <see cref="ItemsSource"/>.</param>
            /// <param name="control">The instantiated control representing this <see cref="Item"/>.</param>
            /// <param name="rect">The <see cref="RectTransform"/> of the <see cref="Control"/>, if defined.</param>
            public ItemInfo(object item, GameObject control, RectTransform rect)
            {
                Item = item;
                Control = control;
                Rect = rect;
            }
        }

        [SerializeField]
        private GameObject _itemTemplate;

        /// <summary>
        /// Gets or sets the DataTemplate (i.e. prefab) used to display each item.
        /// </summary>
        public GameObject ItemTemplate
        {
            get { return _itemTemplate; }
            set
            {
                if (_itemTemplate == value) return;
                _itemTemplate = value;
                ResetCollection(false);
            }
        }

        [SerializeField]
        private DataTemplateSelector _itemTemplateSelector;

        /// <summary>
        /// Gets or sets the custom logic for choosing a template used to display each item.
        /// </summary>
        public DataTemplateSelector ItemTemplateSelector
        {
            get { return _itemTemplateSelector; }
            set
            {
                if (_itemTemplateSelector == value) return;
                _itemTemplateSelector = value;
                ResetCollection(false);
            }
        }

        [Tooltip("When Awaking, destroy any children that are not part of the ItemsSource or the prefab.\nThis is useful where you want to view the items control as it would be with example objects, but don't actually want them to be children at runtime")]
        [SerializeField]
        private bool _destroyChildrenOnAwake = false;

        private IEnumerable _itemsSource;

        /// <summary>
        /// Gets or sets a collection used to generate the content of the <see cref="ItemsControl"/>.
        /// </summary>
        public IEnumerable ItemsSource
        {
            get { return _itemsSource; }
            set
            {
                if (_itemsSource == value) return;
                ResetBindings(_itemsSource, value);
                _itemsSource = value;
                ResetCollection(true);
                OnItemsSourceChanged();
                ItemsSourceChanged.Invoke();
            }
        }

        /// <summary>
        /// The collection of items from the <see cref="ItemsSource"/>, processed into <see cref="ItemInfo"/> objects.
        /// </summary>
        protected readonly List<ItemInfo> _items = new List<ItemInfo>();

        /// <summary>
        /// The collection of the item's GameObjects generated for caching 
        /// </summary>
        private readonly List<GameObjects> _gameObjectsCached = new List<GameObjects>();

        /// <summary>
        /// Correlating items to their cached GameObjects  
        /// </summary>
        private readonly Dictionary<ItemInfo, GameObject> _itemToGameObjectMap = new Dictionary<ItemInfo, GameObject>();

        [Tooltip("Enable caching of GameObjects for items. GameObjects get cached at start, then enabled and disabled when items come and go. This currently isn't supported with the ItemTemplateSelector")]
        [SerializeField]
        private bool _cacheGameObjects;

        [Tooltip("The amount of GameObjects to instatiate at Awake used for items. This amount will automatically increase to accommodate item count")]
        [SerializeField]
        private int _cacheItemPoolSize = 10;

        [SerializeField]
        private UnityEvent _itemsSourceChanged = null;

        /// <summary>
        /// Event called when the <see cref="ItemsSource"/> property changes.
        /// </summary>
        public UnityEvent ItemsSourceChanged { get { return _itemsSourceChanged; } }

        /// <summary>
        /// Gets a value that indicates whether the <see cref="ItemsControl"/> contains items.
        /// </summary>
        public bool HasItems { get { return _items.Count > 0; } }

        [SerializeField]
        private UnityEvent _hasItemsChanged = null;

        /// <summary>
        /// Event called when the <see cref="HasItems"/> property changes.
        /// </summary>
        public UnityEvent HasItemsChanged { get { return _hasItemsChanged; } }

        void Awake()
        {
            // Don't allow caching of GameObjects if there is an itemTemplateSelector, can only cache if there is a specific item template
            if (_itemTemplateSelector != null)
                _cacheGameObjects = false;
            if (_cacheGameObjects)
                InstantiateGameObjectPool();
            if (_destroyChildrenOnAwake)
            {
                for (var i = transform.childCount - 1; i >= 0; i--)
                {
                    var cg = transform.GetChild(i).gameObject;
                    if (cg == ItemTemplate)
                        cg.SetActive(false);
                    else if (_items.All(c => c.Control != cg))
                        Destroy(cg);
                }
            }
        }

        private void InstantiateGameObjectPool()
        {
            if (_gameObjectsCached.Count > 0)
            {
                // This must have already generated the pool, this currently doesn't have support for being called a second time
                Debug.LogWarning("Trying to genernate the pool of list items twice");
                return;
            }
            if (_itemTemplate == null)
            {
                Debug.LogWarning("There is no ItemTemplate set for this ItemsControl list");
                return;
            }
            for (var i = 0; i < _cacheItemPoolSize; i++)
                InstantiateItemToPool();
        }

        private GameObject InstantiateItemToPool()
        {
            var newGameObject = Instantiate(_itemTemplate);
            var rect = newGameObject.GetComponent<RectTransform>();
            if (rect == null)
                newGameObject.transform.parent = transform;
            else
                rect.SetParent(transform, false);
            newGameObject.SetActive(false);
            _gameObjectsCached.Add(newGameObject);
            return newGameObject;
        }

        private void ResetBindings(IEnumerable oldvalue, IEnumerable newvalue)
        {
            if (oldvalue is INotifyCollectionChanged)
            {
                (oldvalue as INotifyCollectionChanged).CollectionChanged -= CollectionChanged;
            }
            if (newvalue is INotifyCollectionChanged)
            {
                (newvalue as INotifyCollectionChanged).CollectionChanged += CollectionChanged;
            }
        }

        /// <summary>
        /// Handler for the <see cref="INotifyCollectionChanged.CollectionChanged"/> event if raised by the <see cref="ItemsSource"/>.
        /// </summary>
        /// <param name="sender">The object that raised the event.</param>
        /// <param name="e">Information about the event.</param>
        protected virtual void CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    AddItems(e.NewItems);
                    break;
                case NotifyCollectionChangedAction.Remove:
                    RemoveItems(e.OldItems);
                    break;
                case NotifyCollectionChangedAction.Replace:
                    RemoveItems(e.OldItems);
                    AddItems(e.NewItems);
                    break;
                case NotifyCollectionChangedAction.Move:
                    MoveItem(e.OldStartingIndex, e.NewStartingIndex);
                    break;
                default:
                    ResetCollection(true);
                    break;
            }
        }

        private void MoveItem(int oldIndex, int newIndex)
        {
            var item = _items[oldIndex];
            //not using RemoveAt, because we can just move the control around.
            _items.RemoveAt(oldIndex);
            _items.Insert(newIndex, item);
            //we just need to change this object's position in the children
            var rect = item.Rect;
            rect.SetSiblingIndex(newIndex);
        }

        private ItemInfo AddItem(object item)
        {
            GameObject control;
            RectTransform rect;

            if (_cacheGameObjects)
            {
                control = GetCachedControl();

                if (control == null)
                {
                    Debug.LogError("Failed to get a control for the item, make sure to set an ItemTemplate");
                    return null;
                }
            }
            else
                control = InstatiateControl(item);

            rect = control.GetComponent<RectTransform>();

            if (rect == null)
                control.transform.parent = transform;
            else
                rect.SetParent(transform, false);

            var info = new ItemInfo(item, control, rect);
            _items.Add(info);

            if (_cacheGameObjects)
                _itemToGameObjectMap.Add(info, control);

            control.SetActive(true);

            var context = control.GetComponent<DataContext>();
            if (context != null)
                context.UpdateValue(item);

            OnItemAdded(info);
            return info;
        }

        private GameObject InstatiateControl(object item)
        {
            // MRMW Start Change - Prefab Selector support
            var itemTemplate = ItemTemplateSelector != null ? ItemTemplateSelector.SelectTemplate(item) : _itemTemplate;
            var control = Instantiate(itemTemplate);
            // MRMW End Change - Prefab Selector support

            return control;
        }

        private GameObject GetCachedControl()
        {
            GameObject control = null;

            if (ItemTemplate == null)
            {
                Debug.LogError("Couldn't find Template or ItemTemplateSelector");
                return null;
            }

            if (_items.Count < _cacheItemPoolSize)
            {
                foreach (var go in _gameObjectsCached)
                {
                    if (!_itemToGameObjectMap.ContainsValue(go))
                    {
                        control = go;
                        break;
                    }
                }
            }

            // This should help prevent regressions when there are more items than the pool is set to contain  
            if (control == null)
            {
                // There wasn't any in the pool left, create a new one
                control = InstantiateItemToPool();
                _cacheItemPoolSize++;
            }

            return control;
        }

        private void AddItems(IEnumerable newItems)
        {
            foreach (var item in newItems)
            {
                AddItem(item);
            }

            HasItemsChanged.Invoke();
        }

        /// <summary>
        /// After an item is added to the controls
        /// </summary>
        /// <param name="info"></param>
        protected virtual void OnItemAdded(ItemInfo info) { }

        private void RemoveItems(IEnumerable oldItems)
        {
            foreach (var item in oldItems)
            {
                RemoveAt(_items.FindIndex(i => i.Item == item));
            }

            HasItemsChanged.Invoke();
        }

        /// <summary>
        /// After an item is removed from controls
        /// </summary>
        /// <param name="info"></param>
        protected virtual void OnItemRemoved(ItemInfo info) { }

        private void ResetCollection(bool allowControlReuse)
        {
            if (_reuseControlsForReset && allowControlReuse)
            {
                //first, we'll solidify the item source.
                var source = new List<object>();
                foreach (var item in _itemsSource)
                    source.Add(item);

                var oldItems = _items.ToArray();
                _items.Clear();
                var toRemove = new List<ItemInfo>(oldItems);

                //lookup for old item -> old control index
                var oldLookup = new Dictionary<object, int>(oldItems.Length);
                for (var i = 0; i < oldItems.Length; i++)
                    oldLookup[oldItems[i].Item] = i;

                for (var i = 0; i < source.Count; i++)
                {
                    //i will be the correct index in _items once it's added, as well as source

                    //try and get the old item control
                    int oldIdx;
                    if (!oldLookup.TryGetValue(source[i], out oldIdx))
                    {
                        //brand new! add it.
                        var item = AddItem(source[i]);
                        //force to the correct position, because old ones aren't removed yet.
                        item.Rect.SetSiblingIndex(i);
                    }
                    else
                    {
                        //in case of duplicate items, we only want to use the first
                        //we'll just make new controls for the rest
                        oldLookup.Remove(source[i]);

                        //we need to move the old control to correct spot.
                        var oldItem = oldItems[oldIdx];
                        toRemove.Remove(oldItem);
                        _items.Add(oldItem);
                        oldItem.Rect.SetSiblingIndex(i);

                        //should we enable this? I'm not sure really.
                        //OnItemAdded(oldItem);
                    }
                }

                //leftovers need to be removed.
                foreach (var item in toRemove)
                {
                    if (_cacheGameObjects)
                    {
                        item.Control.SetActive(false);
                        _itemToGameObjectMap.Remove(item);
                    }
                    else
                    {
                        Destroy(item.Control);
                    }
                }

                HasItemsChanged.Invoke();
            }
            else
            {
                for (var i = _items.Count - 1; i >= 0; i--)
                {
                    RemoveAt(i);
                }
                AddItems(_itemsSource);
            }
        }

        /// <summary>
        /// Fired after the controls have re-created, before the ItemsSourceChanged event is invoked
        /// </summary>
        protected virtual void OnItemsSourceChanged() { }

        void RemoveAt(int idx)
        {
            if (idx < 0) return;
            var item = _items[idx];
            _items.RemoveAt(idx);
            if (_cacheGameObjects)
            {
                // hide item
                item.Control.SetActive(false);
                // free up gameobject from the pool so it can be reasigned
                _itemToGameObjectMap.Remove(item);
            }
            else
            {
                var rect = item.Control.GetComponent<RectTransform>();
                if (rect == null)
                    item.Control.transform.parent = null;
                else
                    rect.SetParent(null, false);

                Destroy(item.Control);
            }
            OnItemRemoved(item);
        }

        void OnDestroy()
        {
            if (_itemsSource is INotifyCollectionChanged)
            {
                (_itemsSource as INotifyCollectionChanged).CollectionChanged -= CollectionChanged;
            }
        }
    }
}
